//
//  UpdateLocalisedStringKeys.swift
//  Locolize.strings
//
//  Created by Dan Leonard on 3/1/18.
//  Copyright © 2018 AutoSource Motors. All rights reserved.
//
// Generates a Swift source file defining an enum with all possible localised string keys.
import Foundation

let projectDirectory = URL(fileURLWithPath: "/Users/macmedan/Desktop/Locoliziation")
var needCustomKey:[String] = []

func generateResourcesEnum(values: [String]? = nil) {
    var newValues: [String]
    if let values = values {
        newValues = values.sorted()
    } else {
        newValues = Array(Set(NSDictionary(contentsOf: projectDirectory.appendingPathComponents(["Locoliziation","Localizable.strings"]))!.allValues as! [String]))
        newValues = newValues.sorted().flatMap{ autoGenerateKeyFrom(value: $0) }
    }

    let enumCases = newValues.map { "    case \($0)" }.joined(separator: "\n")
    let contents = """
    //
    //  Resources.swift
    //  InspectionTool
    //
    //  Created by Dan Leonard on 3/1/18.
    //
    //  This file is autogenerated by \((#file as NSString).lastPathComponent)
    //
    // `r` represents Resource a common practace used in other development enviroments.


    protocol Localizable {
        var tableName: String { get }
        var localized: String { get }
    }

    extension String {
        func localized(bundle: Bundle = .main, tableName: String = "Localizable") -> String {
        // This is to call attention to strings that are not locolised for debugging.
            return NSLocalizedString(self, tableName: tableName, value: "‼️ \\(self) ‼️", comment: "Add to Localizable.strings file")
        }
    }

    extension Localizable where Self: RawRepresentable, Self.RawValue == String {
        var localized: String {
            return rawValue.localized(tableName: tableName)
        }
    }

    public enum r: String, Localizable {
    \(enumCases)

        var tableName: String {
    //TODO: update this to "Localizable" once we are ready to replace the original.
            return "Localizable"
        }
    }
    """

    print("Generated Resources")

//    if needCustomKey.count > 0 {
//        getKeys(true)
//    } else {
        writeData(contents, toPath: "Locoliziation/Resources.swift", completion: {
            print($0)
        })
//    }

}

func getCustomKeyForString( _ newString: String) {
    if let result = autoGenerateKeyFrom(value: newString) {
        print(result)
    }
    print("Error tyring to create key")
}


func locolizeNewString( _ newString: String, newKey: String? = nil) {
    // Removes duplicates
    var newData: String
    var allValues = Array(Set(NSDictionary(contentsOf: projectDirectory.appendingPathComponents(["Locoliziation","Localizable.strings"]))!.allValues as! [String]))

    if allValues.contains(newString) { needCustomKey.append(newString) }
    allValues.append(newString)
    allValues = allValues.sorted().flatMap{ autoGenerateKeyFrom(value: $0) }
    newData = allValues.flatMap{ getEntry(key: newKey, value: $0) }.joined(separator: "\n")

    writeData(newData){ _ in
        generateResourcesEnum(values: allValues)
    }
}

func writeData( _ newData: String, toPath path: String = "Locoliziation/oldFile.strings", completion:((String) -> Void)) {
    let components = path.components(separatedBy: "/")
    do {
        try newData.write(to: projectDirectory.appendingPathComponents(components), atomically: true, encoding: .utf8)
    } catch {
        completion(error.localizedDescription)
    }
}

func getEntry(key: String? = nil, value rawValue: String) -> String? {
    if let key = key {
        return "\n\"\(key)\" = \"\(rawValue.exscapeNewLine)\";\n"
    } else {
        guard let auto = autoGenerateKeyFrom(value: rawValue) else {
            needCustomKey.append(rawValue)
            return nil
        }
        return "\n\"\(auto)\" = \"\(rawValue.exscapeNewLine)\";\n"
    }

}

func autoGenerateKeyFrom(value: String) -> String? {
    return value.camelCased
}

func writeOld() {

    let stringsDictionary = Array(Set(NSDictionary(contentsOf: projectDirectory.appendingPathComponents(["InspectionTool","Localizable.strings"]))!.allValues as! [String])).sorted()
    var newData = ""
    stringsDictionary.forEach { newData.append("\n\"\(autoGenerateKeyFrom(value: $0)!)\" = \"\($0.exscapeNewLine)\";\n") }

    do {
        try newData.write(to: projectDirectory.appendingPathComponents(["InspectionTool", "oldFile.strings"]), atomically: true, encoding: .utf8)
    } catch {
        print(error)
    }
    print("oldFile Created🎉")
}



extension String {

    var camelCased: String {
        var componets = self.components(separatedBy: " ")
        //Filter invalid charicters before adding capitalization
        componets = componets.flatMap{ $0.validChars == "" ? nil : $0.validChars }
        guard let first = componets.first?.lowercased() else { fatalError("Invalid string for enum generation") }
        print(componets.count, components)
        if componets.count == 1 { return "\(first)"}
        let rest = componets.count > 10 ? componets[1...10].flatMap{ $0.capitalized }.joined() : componets.dropFirst().flatMap{ $0.capitalized }.joined()

        return "\(first)\(rest)"
    }

    var validChars: String {
        return String(describing: filter { String($0).rangeOfCharacter(from: .alphanumerics) != nil })
    }

    // for value entry
    var exscapeNewLine: String {
        return self.replacingOccurrences(of: "\n", with: "\\n")
    }
}

extension URL {
    public func appendingPathComponents(_ pathComponents: [String]) -> URL {
        return pathComponents.enumerated().reduce(self) { url, pair in
            return url.appendingPathComponent(pair.element, isDirectory: pair.offset + 1 < pathComponents.count)
        }
    }
}
